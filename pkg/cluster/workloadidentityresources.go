package cluster

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"context"
	"fmt"
	"strings"

	mgmtauthorization "github.com/Azure/azure-sdk-for-go/services/preview/authorization/mgmt/2018-09-01-preview/authorization"
	"github.com/Azure/go-autorest/autorest/azure"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kruntime "k8s.io/apimachinery/pkg/runtime"

	configv1 "github.com/openshift/api/config/v1"

	"github.com/Azure/ARO-RP/pkg/api"
	pkgoperator "github.com/Azure/ARO-RP/pkg/operator"
	"github.com/Azure/ARO-RP/pkg/util/arm"
	"github.com/Azure/ARO-RP/pkg/util/platformworkloadidentity"
	"github.com/Azure/ARO-RP/pkg/util/stringutils"
)

const (
	azureFederatedTokenFileLocation = "/var/run/secrets/openshift/serviceaccount/token"

	ccoSecretNamespace           = "openshift-cloud-credential-operator"
	ccoSecretName                = "azure-credentials"
	ccoSecretFilename            = "azure-ad-pod-identity-webhook-config.yaml"
	authenticationConfigName     = "cluster"
	authenticationConfigFilename = "cluster-authentication-02-config.yaml"
)

func (m *manager) generateWorkloadIdentityResources() (map[string]kruntime.Object, error) {
	if !m.doc.OpenShiftCluster.UsesWorkloadIdentity() {
		return nil, fmt.Errorf("generateWorkloadIdentityResources called for a Cluster Service Principal cluster")
	}

	resources := map[string]kruntime.Object{}
	if platformWorkloadIdentitySecrets, _, err := m.generatePlatformWorkloadIdentitySecretsAndNamespaces(true); err != nil {
		return nil, err
	} else {
		for _, secret := range platformWorkloadIdentitySecrets {
			key := fmt.Sprintf("%s-%s-credentials.yaml", secret.ObjectMeta.Namespace, secret.ObjectMeta.Name)
			resources[key] = secret
		}
	}

	if cloudCredentialOperatorSecret, err := m.generateCloudCredentialOperatorSecret(); err != nil {
		return nil, err
	} else {
		resources[ccoSecretFilename] = cloudCredentialOperatorSecret
	}

	if authenticationConfig, err := m.generateAuthenticationConfig(); err != nil {
		return nil, err
	} else {
		resources[authenticationConfigFilename] = authenticationConfig
	}

	return resources, nil
}

func (m *manager) deployPlatformWorkloadIdentitySecrets(ctx context.Context) error {
	secrets, namespaces, err := m.generatePlatformWorkloadIdentitySecretsAndNamespaces(false)
	if err != nil {
		return err
	}
	resources := []kruntime.Object{}
	for _, namespace := range namespaces {
		resources = append(resources, namespace)
	}
	for _, secret := range secrets {
		resources = append(resources, secret)
	}

	return m.ch.Ensure(ctx, resources...)
}

func (m *manager) generatePlatformWorkloadIdentitySecretsAndNamespaces(isCreate bool) ([]*corev1.Secret, []*corev1.Namespace, error) {
	subscriptionId := m.subscriptionDoc.ID
	tenantId := m.subscriptionDoc.Subscription.Properties.TenantID
	region := m.doc.OpenShiftCluster.Location

	roles := m.platformWorkloadIdentityRolesByVersion.GetPlatformWorkloadIdentityRolesByRoleName()

	secrets := []*corev1.Secret{}
	namespaces := []*corev1.Namespace{}
	for name, identity := range m.doc.OpenShiftCluster.Properties.PlatformWorkloadIdentityProfile.PlatformWorkloadIdentities {
		role, exists := roles[name]
		if !exists {
			return nil, nil, platformworkloadidentity.GetPlatformWorkloadIdentityMismatchError(m.doc.OpenShiftCluster, roles)
		}
		// Skip creating a secret for the ARO Operator. This will be
		// generated by the ARO Operator deployer instead
		// (see pkg/operator/deploy/deploy.go#generateOperatorIdentitySecret())
		if role.OperatorName == pkgoperator.OperatorIdentityName && isCreate {
			continue
		}

		secrets = append(secrets, &corev1.Secret{
			TypeMeta: metav1.TypeMeta{
				APIVersion: corev1.SchemeGroupVersion.Identifier(),
				Kind:       "Secret",
			},
			ObjectMeta: metav1.ObjectMeta{
				Namespace: role.SecretLocation.Namespace,
				Name:      role.SecretLocation.Name,
			},
			Type: corev1.SecretTypeOpaque,
			StringData: map[string]string{
				"azure_client_id":            identity.ClientID,
				"azure_subscription_id":      subscriptionId,
				"azure_tenant_id":            tenantId,
				"azure_region":               region,
				"azure_federated_token_file": azureFederatedTokenFileLocation,
			},
		})

		namespaces = append(namespaces, &corev1.Namespace{
			TypeMeta: metav1.TypeMeta{
				APIVersion: corev1.SchemeGroupVersion.Identifier(),
				Kind:       "Namespace",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name: role.SecretLocation.Namespace,
			},
		})
	}

	return secrets, namespaces, nil
}

func (m *manager) generateCloudCredentialOperatorSecret() (*corev1.Secret, error) {
	tenantId := m.subscriptionDoc.Subscription.Properties.TenantID

	return &corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			APIVersion: corev1.SchemeGroupVersion.Identifier(),
			Kind:       "Secret",
		},
		ObjectMeta: metav1.ObjectMeta{
			Namespace: ccoSecretNamespace,
			Name:      ccoSecretName,
		},
		Type: corev1.SecretTypeOpaque,
		StringData: map[string]string{
			"azure_tenant_id": tenantId,
		},
	}, nil
}

func (m *manager) generateAuthenticationConfig() (*configv1.Authentication, error) {
	oidcIssuer := m.doc.OpenShiftCluster.Properties.ClusterProfile.OIDCIssuer
	if oidcIssuer == nil {
		return nil, fmt.Errorf("oidcIssuer not present in clusterdoc")
	}

	return &configv1.Authentication{
		TypeMeta: metav1.TypeMeta{
			APIVersion: configv1.SchemeGroupVersion.Identifier(),
			Kind:       "Authentication",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: authenticationConfigName,
		},
		Spec: configv1.AuthenticationSpec{
			ServiceAccountIssuer: (string)(*oidcIssuer),
		},
	}, nil
}

// getPlatformWorkloadIdentityFederatedCredName returns a federated identity credential name.
// name length 3-120 characters. It must be alphanumeric, dash, underscore.
func (m *manager) getPlatformWorkloadIdentityFederatedCredName(sa string, identity api.PlatformWorkloadIdentity) (string, error) {
	if !m.doc.OpenShiftCluster.UsesWorkloadIdentity() {
		return "", fmt.Errorf("getPlatformWorkloadIdentityFederatedCredName called for a CSP cluster")
	}

	if strings.TrimSpace(sa) == "" {
		return "", fmt.Errorf("service account name is required")
	}

	identityResourceId, err := azure.ParseResourceID(identity.ResourceID)
	if err != nil {
		return "", err
	}
	clusterResourceId, err := azure.ParseResourceID(m.doc.OpenShiftCluster.ID)
	if err != nil {
		return "", err
	}

	return platformworkloadidentity.GetPlatformWorkloadIdentityFederatedCredName(clusterResourceId, identityResourceId, sa), nil
}

func (m *manager) ensurePlatformWorkloadIdentityRBAC(ctx context.Context) error {
	resourceGroupID := m.doc.OpenShiftCluster.Properties.ClusterProfile.ResourceGroupID
	resourceGroup := stringutils.LastTokenByte(resourceGroupID, '/')

	var toDelete []mgmtauthorization.RoleAssignment
	var toAdd []*arm.Resource

	m.log.Infof("retrieving existing role assignments")
	allExistingRoleAssignments, err := m.roleAssignments.ListForResourceGroup(ctx, resourceGroup, "atScope()")
	if err != nil {
		return err
	}

	roleAssignmentsForManagedResourceGroup := map[string]mgmtauthorization.RoleAssignment{}
	for _, roleAssignment := range allExistingRoleAssignments {
		if strings.EqualFold(*roleAssignment.Scope, resourceGroupID) {
			roleAssignmentsForManagedResourceGroup[*roleAssignment.RoleDefinitionID] = roleAssignment
		}
	}

	platformWorkloadIdentityRoles := m.platformWorkloadIdentityRolesByVersion.GetPlatformWorkloadIdentityRolesByRoleName()

	for roleName, identity := range m.doc.OpenShiftCluster.Properties.PlatformWorkloadIdentityProfile.PlatformWorkloadIdentities {
		role, ok := platformWorkloadIdentityRoles[roleName]
		if !ok {
			return fmt.Errorf("role not found for identity %s", roleName)
		}

		roleDefinitionId := fmt.Sprintf("/subscriptions/%s%s", m.subscriptionDoc.ID, role.RoleDefinitionID)

		if existingRoleAssignment, ok := roleAssignmentsForManagedResourceGroup[roleDefinitionId]; ok {
			if strings.EqualFold(*existingRoleAssignment.PrincipalID, identity.ObjectID) {
				continue
			}

			toDelete = append(toDelete, existingRoleAssignment)
		}

		toAdd = append(toAdd, m.workloadIdentityResourceGroupRBAC(stringutils.LastTokenByte(role.RoleDefinitionID, '/'), identity.ObjectID))
	}

	for _, assignment := range toDelete {
		m.log.Infof("deleting role assignment %s", *assignment.Name)
		_, err := m.roleAssignments.Delete(ctx, *assignment.Scope, *assignment.Name)
		if err != nil {
			return err
		}
	}

	if len(toAdd) > 0 {
		m.log.Infof("creating new role assignments for updated platform workload identities")
		t := &arm.Template{
			Schema:         "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
			ContentVersion: "1.0.0.0",
			Resources:      toAdd,
		}
		err = arm.DeployTemplate(ctx, m.log, m.deployments, resourceGroup, "platformworkloadidentityrbac", t, nil)
		if err != nil {
			return err
		}
	}

	return nil
}
