apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: arohostmount
  annotations:
    metadata.gatekeeper.sh/title: "Host Mount"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      To prevent the creation of non-OpenShift pods with dangerous read/write mounts
spec:
  crd:
    spec:
      names:
        kind: AROHostMount
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            To prevent the creation of non-OpenShift pods with dangerous read/write mounts
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package arohostmount

        import future.keywords.in
        import data.lib.common.is_priv_namespace
        import data.lib.common.is_exempted_account
        import data.lib.common.get_user

        violation[{"msg": msg}] {

          is_pod(input.review.object)
          ns := input.review.object.metadata.namespace
          not is_priv_namespace(ns)

          # user := get_user(input.review)
          not is_exempted_account(input.review)

          c := input_containers[_]
          input_allow_privilege_escalation(c)

          volume := input_hostpath_volumes[_]
          writeable_volume(c, volume.name)

          msg := sprintf("HostPath volume %v is not allowed for write, pod %v.", [volume.name, input.review.object.metadata.name])
        } {

          is_pv(input.review.object)

          # allow the exempted users?
          not is_exempted_account(input.review)

          has_field(input.review.object.spec, "hostPath")
          has_field(input.review.object.spec, "accessModes")
          writeable_pv(input.review.object.spec.accessModes)
          msg := sprintf("HostPath PersistentVolume %v is not allowed for write.", [input.review.object.metadata.name])

        }

        writeable_pv(accessModes) {
          mode := accessModes[_]
          mode in ["ReadWriteOnce", "ReadWriteMany", "ReadWriteOncePod"]
        }

        writeable_volume(container, volume_name) {
            mount := container.volumeMounts[_]
            mount.name == volume_name
            not mount.readOnly
        }

        input_allow_privilege_escalation(c) {
            not has_field(c, "securityContext")
        }
        input_allow_privilege_escalation(c) {
            not c.securityContext.allowPrivilegeEscalation == false
        }

        input_hostpath_volumes[v] {
            v := input.review.object.spec.volumes[_]
            has_field(v, "hostPath")
        }

        has_field(object, field) = true {
            object[field]
        }

        input_containers[c] {
            c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.initContainers[_]
        }

        input_containers[c] {
            c := input.review.object.spec.ephemeralContainers[_]
        }

        is_pv(obj) {
          obj.apiVersion == "v1"
          obj.kind == "PersistentVolume"
        }

        is_pod(obj) {
          obj.apiVersion == "v1"
          obj.kind == "Pod"
        }
      libs:
        - |
          package lib.common
          import future.keywords.in

          # shared structures, functions, etc.

          is_priv_namespace(ns) {
            privileged_ns[ns]
          }

          privileged_ns = {
            # Kubernetes specific namespaces
            "kube-node-lease",
            "kube-public",
            "kube-system",

            # ARO specific namespaces
            "openshift-azure-logging",
            "openshift-azure-operator",
            "openshift-managed-upgrade-operator",
            "openshift-azure-guardrails",

            # OCP namespaces
            "openshift",
            "openshift-apiserver",
            "openshift-apiserver-operator",
            "openshift-authentication-operator",
            "openshift-cloud-controller-manager",
            "openshift-cloud-controller-manager-operator",
            "openshift-cloud-credential-operator",
            "openshift-cluster-csi-drivers",
            "openshift-cluster-machine-approver",
            "openshift-cluster-node-tuning-operator",
            "openshift-cluster-samples-operator",
            "openshift-cluster-storage-operator",
            "openshift-cluster-version",
            "openshift-config",
            "openshift-config-managed",
            "openshift-config-operator",
            "openshift-console",
            "openshift-console-operator",
            "openshift-console-user-settings",
            "openshift-controller-manager",
            "openshift-controller-manager-operator",
            "openshift-dns",
            "openshift-dns-operator",
            "openshift-etcd",
            "openshift-etcd-operator",
            "openshift-host-network",
            "openshift-image-registry",
            "openshift-ingress",
            "openshift-ingress-canary",
            "openshift-ingress-operator",
            "openshift-insights",
            "openshift-kni-infra",
            "openshift-kube-apiserver",
            "openshift-kube-apiserver-operator",
            "openshift-kube-controller-manager",
            "openshift-kube-controller-manager-operator",
            "openshift-kube-scheduler",
            "openshift-kube-scheduler-operator",
            "openshift-kube-storage-version-migrator",
            "openshift-kube-storage-version-migrator-operator",
            "openshift-machine-api",
            "openshift-machine-config-operator",
            "openshift-marketplace",
            "openshift-monitoring",
            "openshift-multus",
            "openshift-network-diagnostics",
            "openshift-network-operator",
            "openshift-oauth-apiserver",
            "openshift-openstack-infra",
            "openshift-operators",
            "openshift-operator-lifecycle-manager",
            "openshift-ovirt-infra",
            "openshift-sdn",
            "openshift-service-ca",
            "openshift-service-ca-operator"
          }

          exempted_service_account = {
            "default",
            "aro-sre",
            "openshift-apiserver-operator",
            "openshift-apiserver-sa",
            "authentication-operator",
            "geneva",
            "aro-operator-worker",
            "cluster-cloud-controller-manager",
            "cloud-credential-operator",
            "azure-disk-csi-driver-controller-sa",
            "azure-disk-csi-driver-node-sa",
            "azure-disk-csi-driver-operator",
            "machine-approver-sa",
            "cluster-node-tuning-operator",
            "tuned",
            "cluster-samples-operator",
            "cluster-storage-operator",
            "csi-snapshot-controller",
            "csi-snapshot-controller-operator",
            "openshift-config-operator",
            "console-operator",
            "console",
            "openshift-controller-manager-operator",
            "openshift-controller-manager-sa",
            "dns-operator",
            "dns",
            "node-resolver",
            "etcd-operator",
            "cluster-image-registry-operator",
            "registry",
            "node-ca",
            "ingress-operator",
            "router",
            "operator",
            "kube-apiserver-operator",
            "kube-controller-manager-operator",
            "openshift-kube-scheduler-operator",
            "kube-storage-version-migrator-operator",
            "kube-storage-version-migrator-sa",
            "cluster-autoscaler-operator",
            "cluster-baremetal-operator",
            "cluster-baremetal-operator",
            "machine-api-controllers",
            "machine-api-operator",
            "machine-config-controller",
            "machine-config-daemon",
            "machine-config-server",
            "managed-upgrade-operator",
            "marketplace-operator",
            "alertmanager-main",
            "cluster-monitoring-operator",
            "grafana",
            "kube-state-metrics",
            "node-exporter",
            "openshift-state-metrics",
            "prometheus-adapter",
            "prometheus-k8s",
            "prometheus-operator",
            "thanos-querier",
            "multus",
            "metrics-daemon-sa",
            "network-diagnostics",
            "oauth-apiserver-sa",
            "collect-profiles",
            "olm-operator-serviceaccount",
            "sdn",
            "sdn-controller",
            "service-ca-operator",
            "service-ca",
            "pruner",
            "machine-api-termination-handler",
            "aro-operator-master",
            "installer-sa",

            # gatekeeper specific
            "gatekeeper-admin"
          }

          get_service_account(obj) = spec {
            obj.kind == "Pod"
            spec := obj.spec.serviceAccountName
          } {
            obj.kind == "CronJob"
            spec := obj.spec.jobTemplate.spec.template.spec.serviceAccountName
          } {
            obj.kind in ["ReplicationController","ReplicaSet","Deployment","StatefulSet","DaemonSet","Job"]
            spec := obj.spec.template.spec.serviceAccountName
          }

          has_service_account(obj) {
            obj.kind in ["Pod","CronJob","ReplicationController","ReplicaSet","Deployment","StatefulSet","DaemonSet","Job"]
          }

          get_user_info(review) = info {
            has_field(review.userInfo, "username")
            username := get_user(review)
            info := sprintf("user name %v", [username])
          } {
            not has_field(review.userInfo, "username")
            has_service_account(review.object)
            sa := get_service_account(review.object)
            info := sprintf("service account %v", [sa])
          }

          # this setup is to handle below case:
          # user default::notfound not allowed to operate in namespace openshift-kube-scheduler
          #
          # assume for cmdline operations, userInfo is always present, which is the only key for user identity
          # while for serviceAccount operations, no userInfo is present, and we have to rely on the serviceAccountName field in the object

          is_exempted_account(review) {
            has_field(review.userInfo, "username")
            username := get_user(review)
            groups := get_user_group(review)
            is_exempted_user_or_groups(username, groups)
            # print("exempted user/groups:", username, groups)
          } {
            not has_field(review.userInfo, "username")
            sa := get_service_account(review.object)
            is_exempted_service_account(sa)
            print("exempted account:", sa)
          }

          is_exempted_service_account(user) {
            exempted_service_account[user]
          }

          get_user(review) = name {
            not has_field(review.userInfo, "username")
            name = "notfound"
          } {
            has_field(review.userInfo, "username")
            name = review.userInfo.username
            print(name)
          }

          get_user_group(review) = out {
              not review.userInfo
              out = []
          }
          get_user_group(review) = out {
              not review.userInfo.groups
              out = []
          }
          get_user_group(review) = out {
              out = review.userInfo.groups
          }

          is_exempted_user_or_groups(user, groups) {
            exempted_user[user]
            print("exempted user:", user)
          } {
            group := [ g | g := groups[_]; (g in cast_set(exempted_groups)) ]
            count(group) > 0
            print("exempted group:", group)
          }

          has_field(object, field) = true {
              object[field]
          }

          is_exempted_user(user) {
            exempted_user[user]
          }

          exempted_user = {
            "system:admin" # comment out temporarily for testing in console
          }

          exempted_groups = {
            # "system:cluster-admins", # kube:admin
            "system:masters" # system:admin
          }
