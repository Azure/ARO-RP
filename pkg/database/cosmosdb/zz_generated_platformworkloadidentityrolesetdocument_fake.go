// Code generated by github.com/bennerv/go-cosmosdb, DO NOT EDIT.

package cosmosdb

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	"github.com/ugorji/go/codec"

	pkg "github.com/Azure/ARO-RP/pkg/api"
)

type fakePlatformWorkloadIdentityRoleSetDocumentTriggerHandler func(context.Context, *pkg.PlatformWorkloadIdentityRoleSetDocument) error
type fakePlatformWorkloadIdentityRoleSetDocumentQueryHandler func(PlatformWorkloadIdentityRoleSetDocumentClient, *Query, *Options) PlatformWorkloadIdentityRoleSetDocumentRawIterator

var _ PlatformWorkloadIdentityRoleSetDocumentClient = &FakePlatformWorkloadIdentityRoleSetDocumentClient{}

// NewFakePlatformWorkloadIdentityRoleSetDocumentClient returns a FakePlatformWorkloadIdentityRoleSetDocumentClient
func NewFakePlatformWorkloadIdentityRoleSetDocumentClient(h *codec.JsonHandle) *FakePlatformWorkloadIdentityRoleSetDocumentClient {
	return &FakePlatformWorkloadIdentityRoleSetDocumentClient{
		jsonHandle:                               h,
		platformWorkloadIdentityRoleSetDocuments: make(map[string]*pkg.PlatformWorkloadIdentityRoleSetDocument),
		triggerHandlers:                          make(map[string]fakePlatformWorkloadIdentityRoleSetDocumentTriggerHandler),
		queryHandlers:                            make(map[string]fakePlatformWorkloadIdentityRoleSetDocumentQueryHandler),
	}
}

// FakePlatformWorkloadIdentityRoleSetDocumentClient is a FakePlatformWorkloadIdentityRoleSetDocumentClient
type FakePlatformWorkloadIdentityRoleSetDocumentClient struct {
	lock                                     sync.RWMutex
	jsonHandle                               *codec.JsonHandle
	platformWorkloadIdentityRoleSetDocuments map[string]*pkg.PlatformWorkloadIdentityRoleSetDocument
	triggerHandlers                          map[string]fakePlatformWorkloadIdentityRoleSetDocumentTriggerHandler
	queryHandlers                            map[string]fakePlatformWorkloadIdentityRoleSetDocumentQueryHandler
	sorter                                   func([]*pkg.PlatformWorkloadIdentityRoleSetDocument)
	etag                                     int
	changeFeedIterators                      []*fakePlatformWorkloadIdentityRoleSetDocumentIterator

	// returns true if documents conflict
	conflictChecker func(*pkg.PlatformWorkloadIdentityRoleSetDocument, *pkg.PlatformWorkloadIdentityRoleSetDocument) bool

	// err, if not nil, is an error to return when attempting to communicate
	// with this Client
	err error
}

// SetError sets or unsets an error that will be returned on any
// FakePlatformWorkloadIdentityRoleSetDocumentClient method invocation
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) SetError(err error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.err = err
}

// SetSorter sets or unsets a sorter function which will be used to sort values
// returned by List() for test stability
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) SetSorter(sorter func([]*pkg.PlatformWorkloadIdentityRoleSetDocument)) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.sorter = sorter
}

// SetConflictChecker sets or unsets a function which can be used to validate
// additional unique keys in a PlatformWorkloadIdentityRoleSetDocument
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) SetConflictChecker(conflictChecker func(*pkg.PlatformWorkloadIdentityRoleSetDocument, *pkg.PlatformWorkloadIdentityRoleSetDocument) bool) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.conflictChecker = conflictChecker
}

// SetTriggerHandler sets or unsets a trigger handler
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) SetTriggerHandler(triggerName string, trigger fakePlatformWorkloadIdentityRoleSetDocumentTriggerHandler) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.triggerHandlers[triggerName] = trigger
}

// SetQueryHandler sets or unsets a query handler
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) SetQueryHandler(queryName string, query fakePlatformWorkloadIdentityRoleSetDocumentQueryHandler) {
	c.lock.Lock()
	defer c.lock.Unlock()

	c.queryHandlers[queryName] = query
}

func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) deepCopy(platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument) (*pkg.PlatformWorkloadIdentityRoleSetDocument, error) {
	var b []byte
	err := codec.NewEncoderBytes(&b, c.jsonHandle).Encode(platformWorkloadIdentityRoleSetDocument)
	if err != nil {
		return nil, err
	}

	platformWorkloadIdentityRoleSetDocument = nil
	err = codec.NewDecoderBytes(b, c.jsonHandle).Decode(&platformWorkloadIdentityRoleSetDocument)
	if err != nil {
		return nil, err
	}

	return platformWorkloadIdentityRoleSetDocument, nil
}

func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) apply(ctx context.Context, partitionkey string, platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument, options *Options, isCreate bool) (*pkg.PlatformWorkloadIdentityRoleSetDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	if c.err != nil {
		return nil, c.err
	}

	platformWorkloadIdentityRoleSetDocument, err := c.deepCopy(platformWorkloadIdentityRoleSetDocument) // copy now because pretriggers can mutate platformWorkloadIdentityRoleSetDocument
	if err != nil {
		return nil, err
	}

	if options != nil {
		err := c.processPreTriggers(ctx, platformWorkloadIdentityRoleSetDocument, options)
		if err != nil {
			return nil, err
		}
	}

	existingPlatformWorkloadIdentityRoleSetDocument, exists := c.platformWorkloadIdentityRoleSetDocuments[platformWorkloadIdentityRoleSetDocument.ID]
	if isCreate && exists {
		return nil, &Error{
			StatusCode: http.StatusConflict,
			Message:    "Entity with the specified id already exists in the system",
		}
	}
	if !isCreate {
		if !exists {
			return nil, &Error{StatusCode: http.StatusNotFound}
		}

		if platformWorkloadIdentityRoleSetDocument.ETag != existingPlatformWorkloadIdentityRoleSetDocument.ETag {
			return nil, &Error{StatusCode: http.StatusPreconditionFailed}
		}
	}

	if c.conflictChecker != nil {
		for _, platformWorkloadIdentityRoleSetDocumentToCheck := range c.platformWorkloadIdentityRoleSetDocuments {
			if c.conflictChecker(platformWorkloadIdentityRoleSetDocumentToCheck, platformWorkloadIdentityRoleSetDocument) {
				return nil, &Error{
					StatusCode: http.StatusConflict,
					Message:    "Entity with the specified id already exists in the system",
				}
			}
		}
	}

	platformWorkloadIdentityRoleSetDocument.ETag = fmt.Sprint(c.etag)
	c.etag++

	c.platformWorkloadIdentityRoleSetDocuments[platformWorkloadIdentityRoleSetDocument.ID] = platformWorkloadIdentityRoleSetDocument

	if err = c.updateChangeFeeds(platformWorkloadIdentityRoleSetDocument); err != nil {
		return nil, err
	}

	return c.deepCopy(platformWorkloadIdentityRoleSetDocument)
}

// Create creates a PlatformWorkloadIdentityRoleSetDocument in the database
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) Create(ctx context.Context, partitionkey string, platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument, options *Options) (*pkg.PlatformWorkloadIdentityRoleSetDocument, error) {
	return c.apply(ctx, partitionkey, platformWorkloadIdentityRoleSetDocument, options, true)
}

// Replace replaces a PlatformWorkloadIdentityRoleSetDocument in the database
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) Replace(ctx context.Context, partitionkey string, platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument, options *Options) (*pkg.PlatformWorkloadIdentityRoleSetDocument, error) {
	return c.apply(ctx, partitionkey, platformWorkloadIdentityRoleSetDocument, options, false)
}

// List returns a PlatformWorkloadIdentityRoleSetDocumentIterator to list all PlatformWorkloadIdentityRoleSetDocuments in the database
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) List(*Options) PlatformWorkloadIdentityRoleSetDocumentIterator {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(c.err)
	}

	platformWorkloadIdentityRoleSetDocuments := make([]*pkg.PlatformWorkloadIdentityRoleSetDocument, 0, len(c.platformWorkloadIdentityRoleSetDocuments))
	for _, platformWorkloadIdentityRoleSetDocument := range c.platformWorkloadIdentityRoleSetDocuments {
		platformWorkloadIdentityRoleSetDocument, err := c.deepCopy(platformWorkloadIdentityRoleSetDocument)
		if err != nil {
			return NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(err)
		}
		platformWorkloadIdentityRoleSetDocuments = append(platformWorkloadIdentityRoleSetDocuments, platformWorkloadIdentityRoleSetDocument)
	}

	if c.sorter != nil {
		c.sorter(platformWorkloadIdentityRoleSetDocuments)
	}

	return NewFakePlatformWorkloadIdentityRoleSetDocumentIterator(platformWorkloadIdentityRoleSetDocuments, 0)
}

// ListAll lists all PlatformWorkloadIdentityRoleSetDocuments in the database
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) ListAll(ctx context.Context, options *Options) (*pkg.PlatformWorkloadIdentityRoleSetDocuments, error) {
	iter := c.List(options)
	return iter.Next(ctx, -1)
}

// Get gets a PlatformWorkloadIdentityRoleSetDocument from the database
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) Get(ctx context.Context, partitionkey string, id string, options *Options) (*pkg.PlatformWorkloadIdentityRoleSetDocument, error) {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return nil, c.err
	}

	platformWorkloadIdentityRoleSetDocument, exists := c.platformWorkloadIdentityRoleSetDocuments[id]
	if !exists {
		return nil, &Error{StatusCode: http.StatusNotFound}
	}

	return c.deepCopy(platformWorkloadIdentityRoleSetDocument)
}

// Delete deletes a PlatformWorkloadIdentityRoleSetDocument from the database
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) Delete(ctx context.Context, partitionKey string, platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument, options *Options) error {
	c.lock.Lock()
	defer c.lock.Unlock()

	if c.err != nil {
		return c.err
	}

	_, exists := c.platformWorkloadIdentityRoleSetDocuments[platformWorkloadIdentityRoleSetDocument.ID]
	if !exists {
		return &Error{StatusCode: http.StatusNotFound}
	}

	delete(c.platformWorkloadIdentityRoleSetDocuments, platformWorkloadIdentityRoleSetDocument.ID)
	return nil
}

// ChangeFeed is unimplemented
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) ChangeFeed(*Options) PlatformWorkloadIdentityRoleSetDocumentIterator {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(c.err)
	}

	newIter, ok := c.List(nil).(*fakePlatformWorkloadIdentityRoleSetDocumentIterator)
	if !ok {
		return NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(fmt.Errorf("internal error"))
	}

	c.changeFeedIterators = append(c.changeFeedIterators, newIter)
	return newIter
}

func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) updateChangeFeeds(platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument) error {
	for _, currentIterator := range c.changeFeedIterators {
		newTpl, err := c.deepCopy(platformWorkloadIdentityRoleSetDocument)
		if err != nil {
			return err
		}
		currentIterator.platformWorkloadIdentityRoleSetDocuments = append(currentIterator.platformWorkloadIdentityRoleSetDocuments, newTpl)
		currentIterator.done = false
	}

	return nil
}

func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) processPreTriggers(ctx context.Context, platformWorkloadIdentityRoleSetDocument *pkg.PlatformWorkloadIdentityRoleSetDocument, options *Options) error {
	for _, triggerName := range options.PreTriggers {
		if triggerHandler := c.triggerHandlers[triggerName]; triggerHandler != nil {
			c.lock.Unlock()
			err := triggerHandler(ctx, platformWorkloadIdentityRoleSetDocument)
			c.lock.Lock()
			if err != nil {
				return err
			}
		} else {
			return ErrNotImplemented
		}
	}

	return nil
}

// Query calls a query handler to implement database querying
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) Query(name string, query *Query, options *Options) PlatformWorkloadIdentityRoleSetDocumentRawIterator {
	c.lock.RLock()
	defer c.lock.RUnlock()

	if c.err != nil {
		return NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(c.err)
	}

	if queryHandler := c.queryHandlers[query.Query]; queryHandler != nil {
		c.lock.RUnlock()
		i := queryHandler(c, query, options)
		c.lock.RLock()
		return i
	}

	return NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(ErrNotImplemented)
}

// QueryAll calls a query handler to implement database querying
func (c *FakePlatformWorkloadIdentityRoleSetDocumentClient) QueryAll(ctx context.Context, partitionkey string, query *Query, options *Options) (*pkg.PlatformWorkloadIdentityRoleSetDocuments, error) {
	iter := c.Query("", query, options)
	return iter.Next(ctx, -1)
}

func NewFakePlatformWorkloadIdentityRoleSetDocumentIterator(platformWorkloadIdentityRoleSetDocuments []*pkg.PlatformWorkloadIdentityRoleSetDocument, continuation int) PlatformWorkloadIdentityRoleSetDocumentRawIterator {
	return &fakePlatformWorkloadIdentityRoleSetDocumentIterator{platformWorkloadIdentityRoleSetDocuments: platformWorkloadIdentityRoleSetDocuments, continuation: continuation}
}

type fakePlatformWorkloadIdentityRoleSetDocumentIterator struct {
	platformWorkloadIdentityRoleSetDocuments []*pkg.PlatformWorkloadIdentityRoleSetDocument
	continuation                             int
	done                                     bool
}

func (i *fakePlatformWorkloadIdentityRoleSetDocumentIterator) NextRaw(ctx context.Context, maxItemCount int, out interface{}) error {
	return ErrNotImplemented
}

func (i *fakePlatformWorkloadIdentityRoleSetDocumentIterator) Next(ctx context.Context, maxItemCount int) (*pkg.PlatformWorkloadIdentityRoleSetDocuments, error) {
	if i.done {
		return nil, nil
	}

	var platformWorkloadIdentityRoleSetDocuments []*pkg.PlatformWorkloadIdentityRoleSetDocument
	if maxItemCount == -1 {
		platformWorkloadIdentityRoleSetDocuments = i.platformWorkloadIdentityRoleSetDocuments[i.continuation:]
		i.continuation = len(i.platformWorkloadIdentityRoleSetDocuments)
		i.done = true
	} else {
		max := i.continuation + maxItemCount
		if max > len(i.platformWorkloadIdentityRoleSetDocuments) {
			max = len(i.platformWorkloadIdentityRoleSetDocuments)
		}
		platformWorkloadIdentityRoleSetDocuments = i.platformWorkloadIdentityRoleSetDocuments[i.continuation:max]
		i.continuation += max
		i.done = i.Continuation() == ""
	}

	return &pkg.PlatformWorkloadIdentityRoleSetDocuments{
		PlatformWorkloadIdentityRoleSetDocuments: platformWorkloadIdentityRoleSetDocuments,
		Count:                                    len(platformWorkloadIdentityRoleSetDocuments),
	}, nil
}

func (i *fakePlatformWorkloadIdentityRoleSetDocumentIterator) Continuation() string {
	if i.continuation >= len(i.platformWorkloadIdentityRoleSetDocuments) {
		return ""
	}
	return fmt.Sprintf("%d", i.continuation)
}

// NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator returns a PlatformWorkloadIdentityRoleSetDocumentRawIterator which
// whose methods return the given error
func NewFakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator(err error) PlatformWorkloadIdentityRoleSetDocumentRawIterator {
	return &fakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator{err: err}
}

type fakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator struct {
	err error
}

func (i *fakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator) Next(ctx context.Context, maxItemCount int) (*pkg.PlatformWorkloadIdentityRoleSetDocuments, error) {
	return nil, i.err
}

func (i *fakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator) NextRaw(context.Context, int, interface{}) error {
	return i.err
}

func (i *fakePlatformWorkloadIdentityRoleSetDocumentErroringRawIterator) Continuation() string {
	return ""
}
