package audit

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"encoding/json"
	"os"
	"runtime"
	"sync"
	"time"

	uuid "github.com/satori/go.uuid"
	"github.com/sirupsen/logrus"

	"github.com/Azure/ARO-RP/pkg/env"
	"github.com/Azure/ARO-RP/pkg/util/audit/schema"
	"github.com/Azure/go-autorest/autorest/to"
)

const (
	auditMetadataCategory    = "auditCategory"
	auditMetadataCreatedTime = "auditCreatedTime"
	auditMetadataFullPayload = "auditFullPayload"
	auditMetadataLogKind     = "logKind"
	auditMetadataOperation   = "auditOperation"
	auditMetadataResult      = "auditResult"
	auditMetadataSource      = "auditSource"
	auditSourceRP            = "aro-rp"

	ifxAuditCloudVer = 1.0
	ifxAuditLogKind  = "ifxaudit"
	ifxAuditName     = "#Ifx.AuditSchema"
	ifxAuditVersion  = 2.1

	// ifxAuditFlags is a collection of values bit-packed into a 64-bit integer.
	// These properties describe how the event should be processed by the pipeline
	// in an implementation-independent way.
	ifxAuditFlags = 257

	// ifxAuditPopSample is the effective percentage sample rate for this event at the
	// time it was generated by a client (either the default value specified in
	// the event definition, system default or a dynamic override from a cloud
	// settings service).
	// not used by Azure
	ifxAuditPopSample = 0.0
)

var (
	// epoch is an unique identifier associated with the current session of the
	// telemetry library running on the platform. It must be stable during a
	// session, and has no implied ordering across sessions.
	epoch = uuid.NewV4().String()

	// seqNum is used to track absolute order of uploaded events, per session.
	// It is reset when the ARO component is restarted. The first log will have
	// its sequence number set to 1.
	seqNum      uint64
	seqNumMutex sync.Mutex
)

type hook struct {
	payload *schema.AuditPayload
}

func (hook) Levels() []logrus.Level {
	return logrus.AllLevels
}

func (h *hook) Fire(log *logrus.Entry) error {
	payload := *h.payload // shallow copy

	payload.EnvTime = to.StringPtr(log.Time.UTC().Format(time.RFC3339))
	payload.EnvSeqNum = nextSeqNum()

	if operationName, ok := log.Data["operationName"].(string); ok {
		payload.OperationName = &operationName
		delete(log.Data, "operationName")
		log.Data[auditMetadataOperation] = operationName
	}

	if category, ok := log.Data[auditMetadataCategory].(string); ok {
		payload.Category = schema.Category(category)
	}

	// etc.

	log.Data[auditMetadataCreatedTime] = *payload.EnvTime
	log.Data[auditMetadataLogKind] = ifxAuditLogKind
	log.Data[auditMetadataResult] = payload.Result.ResultType
	log.Data[auditMetadataSource] = auditSourceRP

	b, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	log.Data[auditMetadataFullPayload] = string(b)

	return nil
}

func AuditLog(env env.Core, logger *logrus.Logger) (*logrus.Entry, error) {
	hostname, err := os.Hostname()
	if err != nil {
		return nil, err
	}

	logger.AddHook(&hook{
		payload: &schema.AuditPayload{
			EnvOS:        to.StringPtr(runtime.GOOS),
			EnvVer:       ifxAuditVersion,
			EnvName:      to.StringPtr(ifxAuditName),
			EnvEpoch:     &epoch,
			EnvPopSample: ifxAuditPopSample,
			EnvFlags:     ifxAuditFlags,
			// TODO: EnvCV
			EnvCloudVer:  ifxAuditCloudVer,
			EnvCloudName: &env.Environment().Name,
			// TODO: EnvCloudRole
			EnvCloudRoleInstance: &hostname,
			EnvCloudLocation:     to.StringPtr(env.Location()),
		},
	})

	return logrus.NewEntry(logger), nil
}

func nextSeqNum() uint64 {
	seqNumMutex.Lock()
	defer seqNumMutex.Unlock()

	seqNum++

	return seqNum
}
