parameters:
  - name: jobName
    type: string
  - name: makeCommand
    type: string
  - name: repository
    type: string
  - name: acrFQDN
    type: string
  - name: imageRepoName
    type: string
  - name: pushLatest
    type: boolean
    default: false

jobs:
  - job: ${{ parameters.jobName }}
    pool:
      name: 1es-aro-ci-pool
    variables:
      ACR_FQDN: ${{ parameters.acrFQDN }}
      REPOSITORY: ${{ parameters.repository }}
      IMAGE_TAG: $(Build.BuildId)  # Include the unique BuildId or another identifier
    steps:
      - template: ../templates/template-checkout.yml

      - task: AzureCLI@2
        inputs:
          azureSubscription: 'ado-pipeline-dev-image-push'  # Service connection name
          scriptType: 'bash'
          scriptLocation: 'inlineScript'
          inlineScript: |
            echo "Retrieving ACR token..."
            REGISTRY_NAME=${ACR_FQDN%%.*}

            if [ -z "$REGISTRY_NAME" ]; then
              echo "Error: ACR_FQDN is not set correctly."
              exit 1
            fi
            TOKEN=$(az acr login --name $REGISTRY_NAME --expose-token --output tsv --query accessToken)

            if [ -z "$TOKEN" ]; then
              echo "Error: Failed to retrieve ACR token."
              exit 1
            fi

            echo "##vso[task.setvariable variable=ACR_TOKEN]$TOKEN"

      - script: |
          set -xe
          export NO_CACHE=true
          export TOKEN=$(ACR_TOKEN)
          export REPOSITORY=${{ parameters.repository }}
          export IMAGE_REPO_NAME=${{ parameters.imageRepoName }}

          # Install podman, make, azure-cli, and Go
          echo "Installing Podman, Make, Azure CLI, and Go..."
          sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
          sudo dnf config-manager --add-repo https://packages.microsoft.com/config/rhel/8/prod.repo
          sudo dnf install -y azure-cli podman make

          # Install Go
          curl -OL https://golang.org/dl/go1.21.11.linux-amd64.tar.gz
          sudo tar -C /usr/local -xzf go1.21.11.linux-amd64.tar.gz
          export PATH=$PATH:/usr/local/go/bin

          # Verify installations
          which make
          make --version
          which podman
          podman --version
          which go
          go version
          whoami

          # Source the podman control script
          echo "Sourcing podman control script and starting podman service..."
          . ./hack/e2e/utils.sh
          run_podman
          validate_podman_running

          # Log in to ACR using Podman
          echo "Logging into ACR with Podman..."
          echo $TOKEN | podman --remote --url=tcp://localhost:8888 login ${ACR_FQDN} -u "00000000-0000-0000-0000-000000000000" --password-stdin --log-level=debug 2>&1 | tee podman_login.log

          # Check if login was successful
          if [ $? -ne 0 ]; then
            echo "Error: Podman login failed."
            cat podman_login.log
            kill_podman
            exit 1
          fi

          echo "Podman login successful."

          # Run the build and generate a unique image tag
          echo "Running the build and capturing the image tag..."
          IMAGE_TAG=$(eval "${{ parameters.makeCommand }}" | grep 'Successfully tagged' | awk '{print $3}' | cut -d':' -f2)

          # If IMAGE_TAG is empty, exit without proceeding to tag and push
          if [ -z "$IMAGE_TAG" ]; then
            echo "Warning: No image was built or tagged by the makeCommand. Skipping image push."
            kill_podman
            exit 0  # Exit successfully as there's no image to tag or push
          fi

          # Continue only if an image was successfully built
          UNIQUE_TAG="${IMAGE_TAG}-$(date +%Y%m%d%H%M%S)-$(Build.BuildId)"
          podman --remote --url=tcp://localhost:8888 images

          echo "Captured UNIQUE_TAG: $UNIQUE_TAG"

          # Retag the image with the ACR repository and unique tag
          echo "Tagging the image with ACR repository..."
          podman --remote --url=tcp://localhost:8888 tag localhost/${IMAGE_REPO_NAME}:${IMAGE_TAG} ${ACR_FQDN}/${REPOSITORY}:${UNIQUE_TAG}

          # Push the image to ACR
          echo "Pushing image to ACR..."
          podman --remote --url=tcp://localhost:8888 push ${ACR_FQDN}/${REPOSITORY}:${UNIQUE_TAG}

          # Optionally tag and push the image as 'latest'
          if [ ${{ parameters.pushLatest }} == true ]; then
            echo "Tagging and pushing latest image..."
            podman --remote --url=tcp://localhost:8888 tag ${ACR_FQDN}/${REPOSITORY}:${UNIQUE_TAG} ${ACR_FQDN}/${REPOSITORY}:latest
            podman --remote --url=tcp://localhost:8888 push ${ACR_FQDN}/${REPOSITORY}:latest
          fi

          # Check for images with label 'stage=rp-build-cache-layer' to extract cover.out
          echo "Checking for images with label 'stage=rp-build-cache-layer'..."
          RP_IMAGE_ID=$(podman image ls --filter label=stage=rp-build-cache-layer --noheading --format '{{.Id}}' | tail -n 1)

          if [ -n "$RP_IMAGE_ID" ]; then
              # If the image exists, extract cover.out
              echo "Found RP image: $RP_IMAGE_ID"
              podman create --name extract_cover_out $RP_IMAGE_ID
              podman cp extract_cover_out:/app/cover.out $(Build.SourcesDirectory)/cover.out
              podman rm extract_cover_out

              # Ensure cover.out was copied
              if [ ! -f $(Build.SourcesDirectory)/cover.out ]; then
                  echo "Error: cover.out file was not extracted successfully."
                  exit 1
              else
                  echo "cover.out file found in $(Build.SourcesDirectory)"
              fi

              # Validate and display cover.out contents
              echo "Contents of cover.out:"
              cat $(Build.SourcesDirectory)/cover.out

              # Check if the file is not empty
              if [ -s $(Build.SourcesDirectory)/cover.out ]; then
                echo "cover.out contains data:"
                head -n 10 $(Build.SourcesDirectory)/cover.out
              else
                echo "cover.out is empty or does not exist."
                exit 1
              fi

              # Convert cover.out to human-readable format (for Go coverage)
              echo "Converting cover.out to human-readable format..."
              go tool cover -func $(Build.SourcesDirectory)/cover.out
          else
              # If no image is found, skip the cover.out extraction
              echo "No RP Image found with label 'stage=rp-build-cache-layer'. Skipping cover.out extraction."
          fi

          # Stop podman
          echo "Stopping Podman service..."
          kill_podman

          # Clear Azure session AFTER all ACR operations are complete
          az account clear
        target: ubi8
