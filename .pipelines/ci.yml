# Azure DevOps Pipeline running CI and E2E

trigger:
  branches:
    include:
      - master
  paths:
    exclude:
      - docs/*
  tags:
    include:
      - v2*

variables:
  - template: vars.yml
  - name: REGISTRY
    value: registry.access.redhat.com
  - name: LOCAL_ARO_RP_IMAGE
    value: "arosvcdev.azurecr.io/aro"
  - name: LOCAL_ARO_AZEXT_IMAGE
    value: "arosvcdev.azurecr.io/azext-aro"
  - name: LOCAL_VPN_IMAGE
    value: "arosvcdev.azurecr.io/vpn"
  - name: LOCAL_E2E_IMAGE
    value: "arosvcdev.azurecr.io/e2e"
  - name: TAG
    value: $(Build.BuildId)
  - name: VERSION
    value: $(Build.BuildId)


stages:
  - stage: Containerized
    jobs:
      - job: Build_Test_And_Push_Az_ARO_Extension
        pool:
          name: 1es-aro-ci-pool
        steps:
          - template: ./templates/template-checkout.yml

          # Build and test the Az ARO Extension
          - script: |
              set -xe
              DOCKER_BUILD_CI_ARGS="--load" make ci-azext-aro VERSION=$(VERSION)
            displayName: ðŸ›  Build & Test Az ARO Extension

          # Push the image to ACR
          - template: ./templates/template-acr-push.yml
            parameters:
              acrFQDN: 'arosvcdev.azurecr.io'
              repository: 'azext-aro'
              pushLatest: true

      - job: Build_And_Test_RP_And_Portal
        pool:
          name: 1es-aro-ci-pool
        steps:
          - template: ./templates/template-checkout.yml

          # Build and test RP and Portal
          - script: |
              set -xe
              DOCKER_BUILD_CI_ARGS="--load" make ci-rp VERSION=$(VERSION)
            displayName: ðŸ›  Build & Test RP and Portal

          # Publish test results
          - task: PublishTestResults@2
            displayName: ðŸ“Š Publish tests results
            inputs:
              testResultsFiles: $(System.DefaultWorkingDirectory)/report.xml
            condition: succeededOrFailed()

          # Publish code coverage results
          - task: PublishCodeCoverageResults@2
            displayName: ðŸ“ˆ Publish code coverage
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: $(System.DefaultWorkingDirectory)/coverage.xml
              failIfCoverageEmpty: false
            condition: succeededOrFailed()

          # Push the image to ACR
          - template: ./templates/template-acr-push.yml
            parameters:
              acrFQDN: 'arosvcdev.azurecr.io'
              repository: 'aro'
              pushLatest: true

  - stage: E2E  # E2E Stage using Docker Compose
    dependsOn: Containerized
    jobs:
      - job: Run_E2E_Tests
        pool:
          name: 1es-aro-ci-pool
        steps:
          # Step 1: Checkout the code
          - template: ./templates/template-checkout.yml

          # Step 2: Install Docker, Docker Compose, and dependencies
          - script: |
              # Install Docker dependencies
               echo "Installing Docker and Docker Compose Plugin..."
              sudo apt-get update
              sudo apt-get install -y ca-certificates curl gnupg
              sudo install -m 0755 -d /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo tee /etc/apt/keyrings/docker.asc
              sudo chmod a+r /etc/apt/keyrings/docker.asc
              echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
              $(. /etc/os-release && echo \"$VERSION_CODENAME\") stable" | \
              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin make
              sudo systemctl start docker
              sudo systemctl enable docker
              docker compose version
            displayName: Install Docker and Docker Compose

          # Step 3: AZ CLI Login
          - template: ./templates/template-az-cli-login.yml
            parameters:
              azureDevOpsJSONSPN: $(aro-v4-e2e-devops-spn)


          # Step 5: Get Kubeconfig for AKS Cluster with corrected Key Vault configuration
          - bash: |
             az account set -s $AZURE_SUBSCRIPTION_ID
              SECRET_SA_ACCOUNT_NAME=$(SECRET_SA_ACCOUNT_NAME) make secrets
              . secrets/env
              export CI=true
              export KEYVAULT_PREFIX="e2e-classic-eastus-cls"
              KEYVAULT_URL="https://${KEYVAULT_PREFIX}.vault.azure.net"
              echo "Using Key Vault URL: $KEYVAULT_URL"

              # Verify if the URL is reachable
              nslookup ${KEYVAULT_PREFIX}.vault.azure.net || {
                echo "Failed to resolve Key Vault DNS. Please check the Key Vault configuration."
                exit 1
              }

              # Retrieve the kubeconfig
              hack/get-admin-aks-kubeconfig.sh > aks.kubeconfig

              if [ -f aks.kubeconfig ]; then
                echo "Kubeconfig retrieved successfully."
                echo "KUBECONFIG=$(pwd)/aks.kubeconfig" >> .env
                cat aks.kubeconfig
              else
                echo "Failed to retrieve Kubeconfig."
                exit 1
              fi
            displayName: Get Kubeconfig for AKS Cluster

          # Step 6: Deploy Hive Operator with fix for unbound PULL_SECRET
          - bash: |
              az account set -s $AZURE_SUBSCRIPTION_ID
              SECRET_SA_ACCOUNT_NAME=$(SECRET_SA_ACCOUNT_NAME) make secrets
              . secrets/env
              export CI=true
              docker compose --env-file .env -f docker-compose.yml up -d vpn
              while [ "$(docker inspect --format '{{.State.Health.Status}}' vpn)" != "healthy" ]; do
                echo "Waiting for VPN to be healthy..."
                sleep 10
              echo "VPN is not healthy yet. Waiting..."
              done
              docker ps
              export KUBECONFIG=$(pwd)/aks.kubeconfig
              kubectl get nodes || {
                echo "Failed to get nodes. Please check the Kubeconfig configuration."
                exit 1
              }
              if [[ -f "hack/hive/hive-dev-install.sh" ]]; then
                ./hack/hive/hive-dev-install.sh
              else
                echo "Hive installation script not found"
                exit 1
              fi
            displayName: Deploy Hive Operator

          # Step 7: Set Up Environment Variables for Docker Compose
          - bash: |
              export RP_IMAGE_ACR=arosvcdev.azurecr.io
              export VERSION=${BUILD_BUILDID}
              export E2E_IMAGE=${RP_IMAGE_ACR}/e2e:${VERSION}
              export E2E_LABEL='!smoke&&!regressiontest'
              echo "RP_IMAGE_ACR=$RP_IMAGE_ACR" > .env
              echo "VERSION=$VERSION" >> .env
              echo "E2E_IMAGE=$E2E_IMAGE" >> .env
              echo "E2E_LABEL=$E2E_LABEL" >> .env
              echo "KUBECONFIG=$(pwd)/aks.kubeconfig" >> .env
              . secrets/env
              cat .env
            displayName: Set Up Environment Variables

          # Step 8: Start Services using Docker Compose
          - bash: |
              az account set -s $AZURE_SUBSCRIPTION_ID
              SECRET_SA_ACCOUNT_NAME=$(SECRET_SA_ACCOUNT_NAME) make secrets
              . secrets/env
              docker compose --env-file .env -f docker-compose.yml up -d
              docker ps
            displayName: Start Services using Docker Compose

          # Step 9: Execute E2E Tests
          - bash: |
              docker compose logs rp
              az account set -s $AZURE_SUBSCRIPTION_ID
              SECRET_SA_ACCOUNT_NAME=$(SECRET_SA_ACCOUNT_NAME) make secrets
              . secrets/env
              export CI=true
              export ARO_SELENIUM_HOSTNAME="localhost"
              export OS_CLUSTER_VERSION=4.13.40
              export E2E_LABEL='!smoke&&!regressiontest'
              . ./hack/e2e/run-rp-and-e2e.sh
              deploy_e2e_db
              register_sub
              env | sort
              docker ps
              docker compose up run-e2e --abort-on-container-exit
            displayName: Execute E2E Tests

          # Step 10: Log the output from the services in case of failure
          - bash: |
              docker compose logs portal
              docker compose logs vpn
              docker compose logs selenium
              docker compose logs rp
              docker compose logs run-e2e
            displayName: Log Service Output
            condition: failed()

          #  must-gather collection must be run inside the container so it can access the VPN
          - bash: |
              export CI=true
              set -x
              hack/get-admin-aks-kubeconfig.sh > aks.kubeconfig
            displayName: Get admin kubeconfig for must-gather
            condition: failed()
          - bash: |
              export CI=true
              export KUBECONFIG=aks.kubeconfig
              wget -nv https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/$(OpenShiftCLIVersion)/openshift-client-linux-$(OpenShiftCLIVersion).tar.gz
              tar xf openshift-client-linux-$(OpenShiftCLIVersion).tar.gz
              ./oc adm must-gather --image quay.io/cmarches/aro-must-gather:20231030.00
               tar cf must-gather.tar.gz must-gather.local.*
            displayName: Collect must-gather
            condition: failed()
            # Publish the must-gather result to the pipeline
          - publish: must-gather.tar.gz
            artifact: must-gather
            displayName: Append must-gather to Pipeline
            condition: failed()

          # Step 11: Clean up Docker Compose services
          - bash: |
              docker compose down
              rm -f aks.kubeconfig
            displayName: Cleanup Docker Compose Services and Kubeconfig
            condition: always()

          # Step 12: Clean Up Database
          - bash: |
              az cosmosdb sql database delete --name "$DATABASE_NAME" --yes --account-name "$DATABASE_ACCOUNT_NAME" --resource-group "$RESOURCEGROUP"
            displayName: Clean Up Database
            condition: always()

          # Cleanup Hive Operator
          - bash: |
              echo "Cleaning up Hive Operator..."
              kubectl delete namespace hive || echo "Namespace already deleted or does not exist."
            displayName: Cleanup Hive Operator
            condition: always()

          # Step 13: AZ CLI Logout
          - template: ./templates/template-az-cli-logout.yml
