# Azure DevOps Pipeline running CI

trigger:
  branches:
    include:
      - master
      - loki/pipeline-swarm
      - loki/pipeline-swarm
  paths:
    exclude:
      - docs/*
  tags:
    include:
      - v2*

pr:
  branches:
    include:
      - loki/pipeline-swarm
  branches:
    include:
      - loki/pipeline-swarm
  paths:
    exclude:
      - docs/*

variables:
  - group: VariableGroupName  # Replace with the name of variable group

resources:
  containers:
    - container: golang
      image: registry.access.redhat.com/ubi8/go-toolset:1.21.11-1.1720406008
      options: --user=0

stages:
- stage: NEW_HOTNESS
  jobs:
    - job: Build_Lint_Test_RP_And_Portal
      pool:
        name: 1es-aro-ci-pool
      steps:
        - template: ./templates/template-checkout.yml
        - script: |
            set -xe
            export RP_IMAGE_ACR=arosvcdev  # Use your new ACR
            export NO_CACHE=true
            make ci-rp

    - job: Build_and_Test_Az_ARO_Extension
      pool:
        name: 1es-aro-ci-pool
      steps:
        - template: ./templates/template-checkout.yml
        - script: |
            set -xe
            export RP_IMAGE_ACR=arosvcdev  # Use your new ACR
            export NO_CACHE=true
            make azext-aro

    - job: Lint_Az_ARO_Extension
      pool:
        name: 1es-aro-ci-pool
      steps:
        - template: ./templates/template-checkout.yml
        - script: |
            set -xe
            make test-python

    - job: Build_Tag_And_Push_Image
      pool:
        vmImage: 'ubuntu-latest'
      variables:
        IMAGE_TAG: $(Build.SourceBranchName)
        REPOSITORY: 'my-image-repo'
        ACR_FQDN: 'arosvcdev.azurecr.io'  # ACR FQDN
        IMAGE_EXISTS: $(Build.SourcesDirectory)/image_exists.txt
      steps:
        - checkout: self

        # Check if the image already exists in ACR
        - task: AzureCLI@2
          inputs:
            azureSubscription: 'ado-pipeline-dev-image-push'  # Service connection name
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az acr repository show-manifests --name ${ACR_FQDN%%.*} --repository ${REPOSITORY} --query "[?tags[?contains(@, '${IMAGE_TAG}')]].digest" -o tsv > ${IMAGE_EXISTS}
              if [ -s ${IMAGE_EXISTS} ]; then
                echo "Image exists."
              else
                echo "Image does not exist, building and pushing."
                docker build -t ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG} .
                docker login ${ACR_FQDN} -u "00000000-0000-0000-0000-000000000000" -p "$(az acr login --name ${ACR_FQDN%%.*} --expose-token --output tsv --query accessToken)"
                docker push ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG}
              fi
          displayName: 'Build, Tag, and Push Docker Image'

    - job: Pull_And_Push_Image_To_ACR
      pool:
        vmImage: 'ubuntu-latest'
      variables:
        ob_outputDirectory: '$(Build.SourcesDirectory)/out'
        IMAGE_TAG: $(Build.SourceBranchName)
        REPOSITORY: 'my-image-repo'
        ACR_FQDN: 'arosvcdev.azurecr.io'  # ACR FQDN
      steps:
        - checkout: self

        # Authenticate with Azure using the Managed Identity service connection
        - task: AzureCLI@2
          inputs:
            azureSubscription: 'ado-pipeline-dev-image-push'  # Service connection name
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              az acr login --name ${ACR_FQDN%%.*}
              docker login ${ACR_FQDN} -u "00000000-0000-0000-0000-000000000000" -p "$(az acr login --name ${ACR_FQDN%%.*} --expose-token --output tsv --query accessToken)"
              
              # Ensure directory is created
              mkdir -p "${ob_outputDirectory}"
              
              # Pull the Docker image from ACR
              docker pull ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG}
              
              # Save the pulled image to a tar file
              docker save ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG} -o ${ob_outputDirectory}/image.tar
          displayName: 'Pulling Docker Image using Docker'

        # Push the Docker image to ACR
        - task: AzureCLI@2
          inputs:
            azureSubscription: 'ado-pipeline-dev-image-push'  # Service connection name
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              docker load -i ${ob_outputDirectory}/image.tar
              docker tag ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG} ${ACR_FQDN}/${REPOSITORY}:latest
              docker push ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG}
              docker push ${ACR_FQDN}/${REPOSITORY}:latest
          displayName: 'Pushing Docker Image to ACR'
      
    - job: Extract_Coverage_Report
      pool:
        vmImage: 'ubuntu-latest'
      variables:
        ACR_FQDN: 'arosvcdev.azurecr.io'  # ACR FQDN
        REPOSITORY: 'my-image-repo'
        IMAGE_TAG: $(Build.SourceBranchName)
      steps:
        - checkout: self

        # Authenticate with ACR using the Managed Identity service connection
        - task: AzureCLI@2
          inputs:
            azureSubscription: 'ado-pipeline-dev-image-push'  # Service connection name
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              docker login ${ACR_FQDN} -u "00000000-0000-0000-0000-000000000000" -p "$(az acr login --name ${ACR_FQDN%%.*} --expose-token --output tsv --query accessToken)"

        - script: |
            set -eux
            # Create a container from the build cache and copy the coverage file
            docker create --name coverage-container ${ACR_FQDN}/${REPOSITORY}:${IMAGE_TAG}
            docker cp coverage-container:/go/src/ARO-RP/cover.out $(Build.SourcesDirectory)/cover.out
            docker rm coverage-container
          displayName: 'Extract Coverage Report from Container'

        # Publish the coverage report to Azure DevOps
        - task: PublishCodeCoverageResults@1
          inputs:
            codeCoverageTool: Cobertura
            summaryFileLocation: $(Build.SourcesDirectory)/cover.out
          displayName: 'Publish Code Coverage Results'

- stage: Golang_Code_Generation
  jobs:
    - job: Run_Golang_Code_Generate
      displayName: "⚙️ Run Golang code generate"
      pool:
        name: 1es-aro-ci-pool
      container: golang
      variables:
        GOCACHE: /tmp/gocache # Set the Go build cache to a writable directory
      steps:
        - template: ./templates/template-checkout.yml
        - script: |
            set -xe
            make generate
            [[ -z "$(git status -s)" ]]
          displayName: "Run Golang Code Generate"
