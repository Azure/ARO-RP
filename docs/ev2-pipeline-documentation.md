# Ev2 Pipeline Documentation

This is a living document that will contain definitions of Ev2 structures as well as a list of parameters for each structure in the Ev2 release pipeline for the ARO-RP. This should serve as a single point of entry for anyone wanting to further develop the Ev2 pipelines.

## Items to address before Draft #1 of this document is complete

1. Define known parameters at this point (in the Glossary section below) and where they will be stored (Azure KeyVault, etc).
1. Monitor Jim Minter's current PR -> <https://github.com/Azure/ARO-RP/pull/1368>
1. Tack on work items to any existing work items to keep this document updated as development progresses.
   1. Discuss our plans on how to keep our Ev2 work in sync with RH's weekly updates

## Concerns

1. Rollout Strategy
   1. Sectors/Stages in ADO
      1. **Sectors/Stages being defined by CF and RH (will update this document when a consensus is achieved**
      1. One Mirroring Deployment Pipeline for PROD and INT
         1. INT and PROD automatically run daily at 0700 UTC
         1. Fairfax is triggered after successful PROD mirror
         
         **Note:** It was agreed upon that Fairfax will be behind INT/PROD due to restrictions needing to pull from Private ACR and not directly from public internet.
      1. Two separate Deployment pipelines for PROD and INT
         1. INT Public and INT Fairfax in parallel
         1. PROD Public and PROD Fairfax in parallel
         1. INT Deployment pipeline to run daily automatically
      1. Manual kick-off of PROD deployment pipeline
         1. Each "sector" will have an approval gate
         1. Public sectors will remain the same
         1. Fairfax sectors TDB.  There are three regions in Fairfax
1. Manifest Generation
   1. Tooling
      1. PowerShell for Ev2 Artifact Generation
         1. Create Base Templates that will be used to generate templates specific to sectors/regions
            1. Rollout Spec Base
            1. Service Model Base
            1. ScopeTags/ScopeBindings (Base): Due to how the Ev2 manifests will be generated ScopeTags and ScopeBindings will not be needed.
            1. Ev2 will retrieve secrets via variable groups and keyvaults so that we reduce our vulnerability exposure in code
      1. ARM Templates
         1. These are currently generated by Golang code in the ARO-RP codebase. The implementation of the RP pipeline will make use of this template generation.
      1. **Parameters - Onebranch**
         1. Onebranch Parameters for Mirroring Pipeline
            Name | Location | Type | Description
            -------------- | ------------------ | -------------- | ----------
            vsoDeployerBuildID | In Pipeline | String | Default: latest
            vso-deployer-pipeline-id | In Pipeline | int |
            vso-project-id | In Pipeline | guid |

      1. **Parameters - Ev2**
         1. Ev2 Specific for Mirroring Pipeline
            Name | Location | Type | Description
            -------------- | ------------------ | -------------- | ----------
            acr-push-auth | Var group | | Used for auth to push images into private ACRs
            quay-pull-auth | Var group | | Pull secret to pull from quay.io
            redhat-pull-auth | Var group | | Pull secret to pull from RH
            dst-acr-name | Ev2 Parameter | | Destination ACR Name
            subscriptionId | | | Subscription Id
            location | | string | Region (East US, West US, etc)

         1. Ev2-Specific

            Name | Location | Type | Description
            -------------- | ------------------ | -------------- | ----------
            ServiceTreeId  | Var group | Guid |
            Environment    |                    | String | Test / Prod
            AzureResourceGroupName | | String
            InstanceOf | | String
            SubscriptionId | | String |
            Location/Region | | String |
            vsoConfigBuildID | Output from Onebranch | String | this may change due to Onebranch
            vsoDeployerBuildID | Output from Onebranch | String | this may change due to Onebranch
            AZURE_CLIENT_ID | Keyvault ?| |
            AZURE_CLIENT_SECRET | Keyvault ?| |
            AZURE_TENANT_ID | | |

         1. ARO-RP-Specific (supplied via Ev2 parameters)

            Name | Location | Type | Description
            -------------- | ------------------ | -------------- | ----------
            AcrResourceId | | | Used for pulling images
            azureDevOpsJSONSPN | | | Combination of AZURE_CLIENT_ID (clientId), AZURE_CLIENT_SECRET (clientSecret), AZURE_TENANT_ID (tenantId)
            StorageAccount | | |
            SubscriptionId | | |
            rpMode | | | "development", "int", or left blank for production

```text
aroVersionStorageAccount: ''
azureDevOpsE2EJSONSPN: ''
azureDevOpsJSONSPN: ''
billingE2EPipelineName: ''
billingE2EBranchName: ''
configFileName: ''
e2eSubscription: ''
environment: ''
locations: []
rpMode: ''
vsoProjectID: ''
vsoConfigPipelineID: ''
vsoConfigBuildID: ''
vsoDeployerPipelineID: ''
vsoDeployerBuildID: ''
```

## Glossary

1. RolloutSpec: The rollout is defined at the "root" of the Ev2 deployment. This is simply a folder that holds json files containing deployment details. At it's core the Rollout points to a ServiceModel (see the "ServiceModel" section below) that determines the resources that will be deployed.
   1. Reference: <https://ev2docs.azure.net/getting-started/authoring/rollout-spec/rolloutspec.html>
   1. Rollout Spec Common Parameters
      1. ContentVersion: This is the version of the Rollout Spec. It can, but does not have to, correspond to the version of the ServiceModel/Build being deployed.
      1. RolloutMetadata.ServiceModelPath: Path to the ServiceModel.json file. This is a filename that could be specified different if multiple service models were being maintained. In our case for the RP one ServiceModel should be sufficient, but this is worth noting for future consideration.
      1. RolloutMetadata.Name: Name of the service being deployed. Typically it is something like "{ServiceName} {BuildNumber}" but it can be anything descriptive.
      1. RolloutMetadata.RolloutType: RolloutType is based on the build being deployed. Values can be Major, Minor, or Hotfix.
      1. OrchestratedSteps: A series of steps that specifies the order of items to deploy in the ServiceModel.
         1. For ARO-RP this will point to the RP application in the ServiceResourceGroups.ServiceResources array.

1. ServiceModel: The ServiceModel specifies the resources that will be deployed across any specified regions.
   1. Reference: <https://ev2docs.azure.net/getting-started/authoring/service-model/servicemodel.html>
   1. For the ARO-RP pipeline we will need to deploy to regions based on sectors defined by the team. The implementation of the Ev2 configuration will be generated using a PowerShell script. It will give us the ability to have configuration files generated for each individual region as well as master files that can be utilized to deploy to all regions at once. This will be further defined as the implementation is copmleted.
   1. ServiceModel Common Parameters:
      1. Environment: Test, Staging, Prod, etc. This can be customized as needed.
      1. ServiceResourceGroupDefinitions: A "serviceResourceGroup" points to a specific Azure Resource Group. The definition here allows for applying a shared set of templates, parameters, and other compositional pieces (such as extensions) to a set of Azure Resource Groups.
      1. ServiceResourceGroup: Specifies the exact Azure Resource Group name to deploy the ARM templates specified in the "serviceResourceGroupDefinition" being referenced. This is the level at which Azure SubscriptionId and Region/Location are specified. Multiple serviceResourceGroups could be a powerful tool to deploy to different clouds.
      1. ServiceResources: Specifies the applications to publish. For ARO-RP this will be the RP application itself.
      1. ScopeTags/ScopeBindings: Due to how the Ev2 manifests will be generated ScopeTags and ScopeBindings will not be needed.

## Callouts

1. For ARM template generation it would be preferable to use static ARM templates maintained by hand over generated for easier maintenance. This is standard practice for Azure.
