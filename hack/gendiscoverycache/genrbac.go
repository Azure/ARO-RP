package main

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"fmt"
	"os"
	"sort"
	"strings"

	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kjson "k8s.io/apimachinery/pkg/runtime/serializer/json"
	"k8s.io/client-go/discovery"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
)

// genRBAC auto-generates the system:aro-sre ClusterRole.  This is close in
// spirit to cluster-reader but is defined separately (a) so that we guarantee
// it always covers all the necessary kinds and (b) so that the operator syncs
// it to avoid unexpected changes.
func genRBAC(restconfig *rest.Config) error {
	cli, err := discovery.NewDiscoveryClientForConfig(restconfig)
	if err != nil {
		return err
	}

	r := &rbacv1.ClusterRole{
		ObjectMeta: metav1.ObjectMeta{
			Name: "system:aro-sre",
		},
	}

	err = walk(cli, func(group string, apiresource *metav1.APIResource) {
		r.Rules = append(r.Rules, sreRules(group, apiresource)...)
	})
	if err != nil {
		return err
	}

	r.Rules = compactRules(r.Rules)

	sort.SliceStable(r.Rules, func(i, j int) bool { return strings.Compare(r.Rules[i].Resources[0], r.Rules[j].Resources[0]) < 0 })
	sort.SliceStable(r.Rules, func(i, j int) bool { return strings.Compare(r.Rules[i].APIGroups[0], r.Rules[j].APIGroups[0]) < 0 })

	r.Rules = append(r.Rules, rbacv1.PolicyRule{
		NonResourceURLs: []string{rbacv1.NonResourceAll},
		Verbs:           []string{"get"},
	})

	serializer := kjson.NewSerializerWithOptions(
		kjson.DefaultMetaFactory, scheme.Scheme, scheme.Scheme,
		kjson.SerializerOptions{Yaml: true},
	)

	yaml := scheme.Codecs.CodecForVersions(serializer, nil, schema.GroupVersions(scheme.Scheme.PrioritizedVersionsAllGroups()), nil)

	f, err := os.Create("pkg/operator/controllers/rbac/staticresources/clusterrole.yaml")
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = fmt.Fprintln(f, "# Code generated by hack/gendiscoverycache; DO NOT EDIT.")
	if err != nil {
		return err
	}

	return yaml.Encode(r, f)
}

func walk(cli discovery.DiscoveryInterface, f func(string, *metav1.APIResource)) error {
	_, resources, err := cli.ServerGroupsAndResources()
	if err != nil {
		return err
	}

	for _, apiresources := range resources {
		gv, err := schema.ParseGroupVersion(apiresources.GroupVersion)
		if err != nil {
			return err
		}

		for _, apiresource := range apiresources.APIResources {
			f(gv.Group, &apiresource)
		}
	}

	return nil
}

func sreRules(group string, apiresource *metav1.APIResource) (prs []rbacv1.PolicyRule) {
	if group == "oauth.openshift.io" {
		return
	}

	if group == "" && apiresource.Name == "secrets" {
		return
	}

	if strings.ContainsRune(apiresource.Name, '/') &&
		!strings.HasSuffix(apiresource.Name, "/log") {
		return
	}

	for _, verb := range apiresource.Verbs {
		if isReadOnly(group, apiresource, verb) {
			prs = append(prs, rbacv1.PolicyRule{
				APIGroups: []string{group},
				Resources: []string{apiresource.Name},
				Verbs:     []string{verb},
			})
		}
	}

	return
}

func isReadOnly(group string, apiresource *metav1.APIResource, verb string) bool {
	switch verb {
	case "get", "list", "watch":
		return true
	case "create":
		// These kinds are not actually persisted to etcd;  create is kind-of
		// like get here.
		gr := schema.GroupResource{Group: group, Resource: apiresource.Name}.String()
		switch gr {
		case "tokenreviews.authentication.k8s.io",
			"selfsubjectaccessreviews.authorization.k8s.io",
			"selfsubjectrulesreviews.authorization.k8s.io",
			"subjectaccessreviews.authorization.k8s.io",
			"resourceaccessreviews.authorization.openshift.io",
			"subjectaccessreviews.authorization.openshift.io":
			return true
		}
	}
	return false
}
