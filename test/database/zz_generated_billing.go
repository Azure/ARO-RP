// Code generated by hack/gentestdb, DO NOT EDIT.

package database

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"bytes"
	"context"
	"errors"
	"net/http"
	"sync"

	"github.com/ugorji/go/codec"

	"github.com/Azure/ARO-RP/pkg/api"
	"github.com/Azure/ARO-RP/pkg/database/cosmosdb"
)

type fakeBilling struct {
	docs       map[string]*string
	jsonHandle *codec.JsonHandle
	lock       sync.Locker
}

func newBilling(h *codec.JsonHandle) *fakeBilling {
	return &fakeBilling{
		docs:       make(map[string]*string),
		jsonHandle: h,
		lock:       &sync.Mutex{},
	}
}

func (c *fakeBilling) fromString(s *string) (*api.BillingDocument, error) {
	res := &api.BillingDocument{}
	d := codec.NewDecoder(bytes.NewBufferString(*s), c.jsonHandle)
	err := d.Decode(&res)
	return res, err
}

func (c *fakeBilling) Create(ctx context.Context, partitionkey string, doc *api.BillingDocument, options *cosmosdb.Options) (*api.BillingDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if ext {
		// it's here
		return nil, errors.New("Document already exists?")
	}

	buf := &bytes.Buffer{}
	err := codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out
	return c.fromString(&out)
}

func (c *fakeBilling) List(*cosmosdb.Options) cosmosdb.BillingDocumentRawIterator {
	return nil
}

func (c *fakeBilling) ListAll(context.Context, *cosmosdb.Options) (*api.BillingDocuments, error) {
	return nil, errors.New("not implemented")
}

func (c *fakeBilling) Get(ctx context.Context, partitionkey string, documentId string, options *cosmosdb.Options) (*api.BillingDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	out, ext := c.docs[documentId]
	if !ext {
		return nil, &cosmosdb.Error{StatusCode: http.StatusNotFound}
	}

	dec, err := c.fromString(out)
	if err != nil {
		return nil, err
	}

	return dec, err
}
func (c *fakeBilling) Replace(ctx context.Context, partitionkey string, doc *api.BillingDocument, options *cosmosdb.Options) (*api.BillingDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		// it's here
		return nil, errors.New("does not exist")
	}

	buf := &bytes.Buffer{}
	err := codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out
	return c.fromString(&out)
}

func (c *fakeBilling) Delete(ctx context.Context, partitionKey string, doc *api.BillingDocument, options *cosmosdb.Options) error {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		return errors.New("does not exist")
	}

	delete(c.docs, doc.ID)
	return nil
}

func (c *fakeBilling) Query(name string, query *cosmosdb.Query, options *cosmosdb.Options) cosmosdb.BillingDocumentRawIterator {
	return nil
}

func (c *fakeBilling) QueryAll(ctx context.Context, partitionkey string, query *cosmosdb.Query, options *cosmosdb.Options) (*api.BillingDocuments, error) {
	return nil, errors.New("not implemented but for get")
}

func (c *fakeBilling) ChangeFeed(*cosmosdb.Options) cosmosdb.BillingDocumentIterator {
	return nil
}

type fakeBillingRawIterator struct {
	docs []*api.BillingDocument
}

func (i *fakeBillingRawIterator) Next(ctx context.Context, maxItemCount int) (*api.BillingDocuments, error) {
	docs := &api.BillingDocuments{}
	err := i.NextRaw(ctx, maxItemCount, docs)
	return docs, err
}

func (i *fakeBillingRawIterator) NextRaw(ctx context.Context, maxItemCount int, raw interface{}) error {
	if maxItemCount == -1 {
		d := raw.(*api.BillingDocuments)
		d.Count = len(i.docs)
		d.BillingDocuments = i.docs
		return nil
	} else {
		return errors.New("not implemented")
	}
}

func (i *fakeBillingRawIterator) Continuation() string {
	return ""
}
