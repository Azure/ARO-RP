// Code generated by hack/gentestdb, DO NOT EDIT.

package database

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

{{ $cfg := . }}

import (
	"github.com/Azure/ARO-RP/pkg/database"
	"bytes"
	"context"
	"errors"
	"sync"
	"time"

	"github.com/ugorji/go/codec"

	"github.com/Azure/ARO-RP/pkg/api"
	"github.com/Azure/ARO-RP/pkg/database/cosmosdb"
)

type fake{{ $cfg.Name }} struct {
	docs       map[string]*string
	jsonHandle *codec.JsonHandle
	lock       sync.Locker
}

func new{{ $cfg.Name }}(h *codec.JsonHandle) *fake{{ $cfg.Name }} {
	return &fake{{ $cfg.Name }}{
		docs:       make(map[string]*string),
		jsonHandle: h,
		lock:       &sync.Mutex{},
	}
}

func (c *fake{{ $cfg.Name }}) fromString(s *string) (*api.{{ $cfg.DocumentInterface }}, error) {

	res := &api.{{ $cfg.DocumentInterface }}{}
	d := codec.NewDecoder(bytes.NewBufferString(*s), c.jsonHandle)
	err := d.Decode(&res)

	return res, err

}

func (c *fake{{ $cfg.Name }}) Create(ctx context.Context, partitionkey string, doc *api.{{ $cfg.DocumentInterface }}, options *cosmosdb.Options) (*api.{{ $cfg.DocumentInterface }}, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	var err error

	_, ext := c.docs[doc.ID]
	if ext {
		// it's here
		return nil, errors.New("sdkjfbg")
	}

	buf := &bytes.Buffer{}
	err = codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out

	return c.fromString(&out)

}
func (c *fake{{ $cfg.Name }}) List(*cosmosdb.Options) cosmosdb.{{ $cfg.DocumentInterface }}RawIterator {
	return nil
}
func (c *fake{{ $cfg.Name }}) ListAll(context.Context, *cosmosdb.Options) (*api.{{ $cfg.DocumentInterface }}s, error) {
	return nil, errors.New("not implemented")
}
func (c *fake{{ $cfg.Name }}) Get(ctx context.Context, partitionkey string, documentId string, options *cosmosdb.Options) (*api.{{ $cfg.DocumentInterface }}, error) {
	c.lock.Lock()
	defer c.lock.Unlock()
	out, ext := c.docs[documentId]

	if !ext {
		return nil, &cosmosdb.Error{StatusCode: http.StatusNotFound}
	}

	dec, err := c.fromString(out)
	if err != nil {
		return nil, err
	}

	{{ if $cfg.UsesPartitions }}
	if dec.PartitionKey != partitionkey {
		return nil, errors.New("mismatching partition key")
	}
	{{ end }}

	return dec, err

}
func (c *fake{{ $cfg.Name }}) Replace(ctx context.Context, partitionkey string, doc *api.{{ $cfg.DocumentInterface }}, options *cosmosdb.Options) (*api.{{ $cfg.DocumentInterface }}, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		// it's here
		return nil, errors.New("does not exist")
	}
	{{ if $cfg.UsesLeases }}
	if options != nil {
		for _, o := range options.PreTriggers {
			if o == "renewLease" {
				doc.LeaseExpires = int(time.Now().Unix()) + 60
			}
		}
	}
	{{ end }}

	buf := &bytes.Buffer{}
	err := codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out

	return c.fromString(&out)

}

func (c *fake{{ $cfg.Name }}) Delete(ctx context.Context, partitionKey string, doc *api.{{ $cfg.DocumentInterface }}, options *cosmosdb.Options) error {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		return errors.New("does not exist")
	}

	delete(c.docs, doc.ID)

	return nil
}

{{ if ne $cfg.Name "OpenShiftClusters" }}
func (c *fake{{ $cfg.Name }}) Query(name string, query *cosmosdb.Query, options *cosmosdb.Options) cosmosdb.{{ $cfg.DocumentInterface }}RawIterator {
	return nil
}
func (c *fake{{ $cfg.Name }}) QueryAll(ctx context.Context, partitionkey string, query *cosmosdb.Query, options *cosmosdb.Options) (*api.{{ $cfg.DocumentInterface }}s, error) {
return nil, errors.New("not implemented but for get")
}
{{ end }}

func (c *fake{{ $cfg.Name }}) ChangeFeed(*cosmosdb.Options) cosmosdb.{{ $cfg.DocumentInterface }}Iterator {
	return nil
}

type fake{{ $cfg.Name }}RawIterator struct {
	docs []*api.{{ $cfg.DocumentInterface }}
}

func (i *fake{{ $cfg.Name }}RawIterator) Next(ctx context.Context, maxItemCount int) (*api.{{ $cfg.DocumentInterface }}s, error) {
	docs := &api.{{ $cfg.DocumentInterface }}s{}
	err := i.NextRaw(ctx, maxItemCount, docs)
	return docs, err
}

func (i *fake{{ $cfg.Name }}RawIterator) NextRaw(ctx context.Context, maxItemCount int, raw interface{}) error {
	if maxItemCount == -1 {
		d := raw.(*api.{{ $cfg.DocumentInterface }}s)
		d.Count = len(i.docs)
		d.{{ $cfg.DocumentInterface }}s = i.docs
		return nil
	} else {
		return errors.New("not implemented")
	}
}

func (i *fake{{ $cfg.Name }}RawIterator) Continuation() string {
	return ""
}
