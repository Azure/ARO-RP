// Code generated by hack/gentestdb, DO NOT EDIT.

package database

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"bytes"
	"context"
	"errors"
	"net/http"
	"sync"
	"time"

	"github.com/ugorji/go/codec"

	"github.com/Azure/ARO-RP/pkg/api"
	"github.com/Azure/ARO-RP/pkg/database/cosmosdb"
)

type fakeOpenShiftClusters struct {
	docs       map[string]*string
	jsonHandle *codec.JsonHandle
	lock       sync.Locker
}

func newOpenShiftClusters(h *codec.JsonHandle) *fakeOpenShiftClusters {
	return &fakeOpenShiftClusters{
		docs:       make(map[string]*string),
		jsonHandle: h,
		lock:       &sync.Mutex{},
	}
}

func (c *fakeOpenShiftClusters) fromString(s *string) (*api.OpenShiftClusterDocument, error) {
	res := &api.OpenShiftClusterDocument{}
	d := codec.NewDecoder(bytes.NewBufferString(*s), c.jsonHandle)
	err := d.Decode(&res)
	return res, err
}

func (c *fakeOpenShiftClusters) Create(ctx context.Context, partitionkey string, doc *api.OpenShiftClusterDocument, options *cosmosdb.Options) (*api.OpenShiftClusterDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if ext {
		// it's here
		return nil, errors.New("Document already exists?")
	}

	buf := &bytes.Buffer{}
	err := codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out
	return c.fromString(&out)
}

func (c *fakeOpenShiftClusters) List(*cosmosdb.Options) cosmosdb.OpenShiftClusterDocumentRawIterator {
	return nil
}

func (c *fakeOpenShiftClusters) ListAll(context.Context, *cosmosdb.Options) (*api.OpenShiftClusterDocuments, error) {
	return nil, errors.New("not implemented")
}

func (c *fakeOpenShiftClusters) Get(ctx context.Context, partitionkey string, documentId string, options *cosmosdb.Options) (*api.OpenShiftClusterDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	out, ext := c.docs[documentId]
	if !ext {
		return nil, &cosmosdb.Error{StatusCode: http.StatusNotFound}
	}

	dec, err := c.fromString(out)
	if err != nil {
		return nil, err
	}

	if dec.PartitionKey != partitionkey {
		return nil, errors.New("mismatching partition key")
	}

	return dec, err
}
func (c *fakeOpenShiftClusters) Replace(ctx context.Context, partitionkey string, doc *api.OpenShiftClusterDocument, options *cosmosdb.Options) (*api.OpenShiftClusterDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		// it's here
		return nil, errors.New("does not exist")
	}

	if options != nil {
		for _, o := range options.PreTriggers {
			if o == "renewLease" {
				doc.LeaseExpires = int(time.Now().Unix()) + 60
			}
		}
	}

	buf := &bytes.Buffer{}
	err := codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out
	return c.fromString(&out)
}

func (c *fakeOpenShiftClusters) Delete(ctx context.Context, partitionKey string, doc *api.OpenShiftClusterDocument, options *cosmosdb.Options) error {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		return errors.New("does not exist")
	}

	delete(c.docs, doc.ID)
	return nil
}

func (c *fakeOpenShiftClusters) ChangeFeed(*cosmosdb.Options) cosmosdb.OpenShiftClusterDocumentIterator {
	return nil
}

type fakeOpenShiftClustersRawIterator struct {
	docs []*api.OpenShiftClusterDocument
}

func (i *fakeOpenShiftClustersRawIterator) Next(ctx context.Context, maxItemCount int) (*api.OpenShiftClusterDocuments, error) {
	docs := &api.OpenShiftClusterDocuments{}
	err := i.NextRaw(ctx, maxItemCount, docs)
	return docs, err
}

func (i *fakeOpenShiftClustersRawIterator) NextRaw(ctx context.Context, maxItemCount int, raw interface{}) error {
	if maxItemCount == -1 {
		d := raw.(*api.OpenShiftClusterDocuments)
		d.Count = len(i.docs)
		d.OpenShiftClusterDocuments = i.docs
		return nil
	} else {
		return errors.New("not implemented")
	}
}

func (i *fakeOpenShiftClustersRawIterator) Continuation() string {
	return ""
}
