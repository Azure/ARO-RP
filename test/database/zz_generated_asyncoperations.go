// Code generated by hack/gentestdb, DO NOT EDIT.

package database

// Copyright (c) Microsoft Corporation.
// Licensed under the Apache License 2.0.

import (
	"bytes"
	"context"
	"errors"
	"net/http"
	"sync"

	"github.com/ugorji/go/codec"

	"github.com/Azure/ARO-RP/pkg/api"
	"github.com/Azure/ARO-RP/pkg/database/cosmosdb"
)

type fakeAsyncOperations struct {
	docs       map[string]*string
	jsonHandle *codec.JsonHandle
	lock       sync.Locker
}

func newAsyncOperations(h *codec.JsonHandle) *fakeAsyncOperations {
	return &fakeAsyncOperations{
		docs:       make(map[string]*string),
		jsonHandle: h,
		lock:       &sync.Mutex{},
	}
}

func (c *fakeAsyncOperations) fromString(s *string) (*api.AsyncOperationDocument, error) {

	res := &api.AsyncOperationDocument{}
	d := codec.NewDecoder(bytes.NewBufferString(*s), c.jsonHandle)
	err := d.Decode(&res)

	return res, err

}

func (c *fakeAsyncOperations) Create(ctx context.Context, partitionkey string, doc *api.AsyncOperationDocument, options *cosmosdb.Options) (*api.AsyncOperationDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	var err error

	_, ext := c.docs[doc.ID]
	if ext {
		// it's here
		return nil, errors.New("sdkjfbg")
	}

	buf := &bytes.Buffer{}
	err = codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out

	return c.fromString(&out)

}
func (c *fakeAsyncOperations) List(*cosmosdb.Options) cosmosdb.AsyncOperationDocumentRawIterator {
	return nil
}
func (c *fakeAsyncOperations) ListAll(context.Context, *cosmosdb.Options) (*api.AsyncOperationDocuments, error) {
	return nil, errors.New("not implemented")
}
func (c *fakeAsyncOperations) Get(ctx context.Context, partitionkey string, documentId string, options *cosmosdb.Options) (*api.AsyncOperationDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()
	out, ext := c.docs[documentId]

	if !ext {
		return nil, &cosmosdb.Error{StatusCode: http.StatusNotFound}
	}

	dec, err := c.fromString(out)
	if err != nil {
		return nil, err
	}

	return dec, err

}
func (c *fakeAsyncOperations) Replace(ctx context.Context, partitionkey string, doc *api.AsyncOperationDocument, options *cosmosdb.Options) (*api.AsyncOperationDocument, error) {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		// it's here
		return nil, errors.New("does not exist")
	}

	buf := &bytes.Buffer{}
	err := codec.NewEncoder(buf, c.jsonHandle).Encode(doc)
	if err != nil {
		return nil, err
	}

	out := buf.String()
	c.docs[doc.ID] = &out

	return c.fromString(&out)

}

func (c *fakeAsyncOperations) Delete(ctx context.Context, partitionKey string, doc *api.AsyncOperationDocument, options *cosmosdb.Options) error {
	c.lock.Lock()
	defer c.lock.Unlock()

	_, ext := c.docs[doc.ID]
	if !ext {
		return errors.New("does not exist")
	}

	delete(c.docs, doc.ID)

	return nil
}

func (c *fakeAsyncOperations) Query(name string, query *cosmosdb.Query, options *cosmosdb.Options) cosmosdb.AsyncOperationDocumentRawIterator {
	return nil
}
func (c *fakeAsyncOperations) QueryAll(ctx context.Context, partitionkey string, query *cosmosdb.Query, options *cosmosdb.Options) (*api.AsyncOperationDocuments, error) {
	return nil, errors.New("not implemented but for get")
}

func (c *fakeAsyncOperations) ChangeFeed(*cosmosdb.Options) cosmosdb.AsyncOperationDocumentIterator {
	return nil
}

type fakeAsyncOperationsRawIterator struct {
	docs []*api.AsyncOperationDocument
}

func (i *fakeAsyncOperationsRawIterator) Next(ctx context.Context, maxItemCount int) (*api.AsyncOperationDocuments, error) {
	docs := &api.AsyncOperationDocuments{}
	err := i.NextRaw(ctx, maxItemCount, docs)
	return docs, err
}

func (i *fakeAsyncOperationsRawIterator) NextRaw(ctx context.Context, maxItemCount int, raw interface{}) error {
	if maxItemCount == -1 {
		d := raw.(*api.AsyncOperationDocuments)
		d.Count = len(i.docs)
		d.AsyncOperationDocuments = i.docs
		return nil
	} else {
		return errors.New("not implemented")
	}
}

func (i *fakeAsyncOperationsRawIterator) Continuation() string {
	return ""
}
